## Kubernetes Code's

- Yaml synatx check: [https://yamlchecker.com/]
- Save all the files in K8's file with the same naming conventions
- ```Namespace```: which is like a logical group which means you can deploy multiple applications in one cluster
### Execution Steps
- Login into your slave system
```
cd /opt
ls
mkdir kubernetes
cd kubernetes
vi deployment.yaml   ## Copy the code pasted below with modifications
vi namespace.yaml
kubectl get ns      ## To get the default namespaces
kubectl apply -f filename.yaml   ## To execute the .yaml file in kubectl env
 - kubectl apply -f deployment.yaml
 - kubectl apply -f namespace.yaml
kubectl get all -n created-namespace
 - kubectl get all -n dev-udemy-namespace    ## created namespace
kubectl describe pod namepod created -n dev-udemy-namespace
```

### Creating a new user in Jfrog
- Login to your Jfrog Url
- Top right click on Administration
- On the left panel click on User management
   - User
   - Top right click on +New user
   - Give the required credentials (username & Password)
- Now we login docker
   - Give the username  & password created
 - Make sure you change the username in ```deployment.yaml``` file
 
```
docker login paste your jfrog url
 - docker login https://devopsudemy.jfrog.io
```
- If you have already configured no problems else remove
```
rm -rf /root/.docker/config.json
```
- Now you have to extract the encrypted password
```
cat /root/.docker/config.json | base64 -w0
```
- Now copy the encrypted code & paste it in secret.yaml inthe below code block in ```secret.yaml```
```
data:
  .dockerconfigjson: ---- Paste the Copied code here------
type: kubernetes.io/dockerconfigjson


kubectl apply -f secret.yaml                    ## Run this command
kubectl get secrets -n dev-udemy-namespace      ## Gives the no.of secrets under this name space
```
- AFter updating the username created in jfrog in deployment.yaml
```
 spec:
      imagePullSecrets:         ## To retreive the credentials of Jfrog
      - name: jfrogcred         ## Paste the username craeted in Jfrog
      containers:
```
- Execute the deployment file
```
kubectl apply -f deployment.yaml
kubectl get all -n dev-udemy-namespace
kubectl describe ----pod name---- -n dev-udemy-namespace
```
- Now create ```service.yaml``` file and make necessary changes
```
kubectl apply -f service.yaml
kubectl get all -n dev-udemy-namespace      ## Now you can see a port attached to the pod
```
- Login in to your aws account go to your cluster
```
- under security
- click on the security group
- Edit inbound rules
- ![image](https://github.com/user-attachments/assets/70637c79-482b-49ce-a737-aa2fb5df9aa1)
- The above is you have create the SG
```
- Now copy the public i/p of the cluster,so 30082 is the port where you can access the pod
```
public i/p:30082
```

### Namespace.yaml
- While creating the namespace make sure you keep '-' not '_' as it has some restrictions to create a file name
```
apiVersion: v1
kind: Namespace
metadata:
 name: dev-udemy-namespace
```






### Deployemnt.yaml
```
apiVersion: apps/v1
kind: Deployment                ## Which means it creates deployment type of resource
metadata:
  name: dev-udemy-rtp           ## Name of the deployment
  namespace: dev-udemy-namespace             ## Name which you have declared in namespace file
spec:
  replicas: 1
  selector:                     ## This space is basically for the inter-communication of the service
    matchLabels:
      app:  dev-udemy-rtp
  template:                     ## Required configuration to run the POD
    metadata:
      labels:
        app:  dev-udemy-rtp
    spec:
      imagePullSecrets:         ## To retreive the credentials of Jfrog
      - name: jfrogcred         ## Paste the username craeted in Jfrog
      containers:
      - name:  dev-udemy-rtp
        image: devopsudemy.jfrog.io/testdocker-docker/ttrend:2.1.2   ## From where to pull the image
        imagePullPolicy: Always
        ports:
        - containerPort: 8000                                ## Application running port number
        env:
        - name: CONSUMER_KEY
          value: "G6lmKhsi0V9TvXt6oKTfjRBCr"
        - name: CONSUMER_SECRET
          value: "bEyDk8X0p8SQd4376eoNV4nH8To22sHcJOoFt0ZqOKS37hhI4q"
        - name: ACCESS_TOKEN
          value: "9703354-52rXHD6EeOQeYyhtNz1w8UVOgbcLcgOo4O7MB6WV3"
        - name: ACCESS_TOKEN_SECRET
          value: "zBThlZDEp8qnu7NwwdHNth8eg3Rf9zqbvUEFUTaZtN2SF"

```




### Secret.yaml
```
apiVersion: v1
kind: Secret
metadata:
  name: jfrogcred
  namespace: dev_udemy_namespace
data:
  .dockerconfigjson: ---- Paste the Copied code here------
type: kubernetes.io/dockerconfigjson


```




### Service.yaml

- spec:
  type: NodePort

So we have 3 types of services
- Node port
- CLuster IP
- Load balancer

```
apiVersion: v1
kind: Service                           ## Which means it creates service type of resource
metadata:
  name: dev-udemy-rtp-service           ## Name for service
  namespace: dev-udemy-namespace        ## Declared in namespace file
spec:
  type: NodePort                        ## used when you want to access the application from outside the cluster
  selector:
    app: dev-udemy-rtp                  ## Under selector in deployment file
  ports:
  - nodePort: 30082                     ## This port is used to acess the cluster from outside
    port: 8000
    targetPort: 8000
```
